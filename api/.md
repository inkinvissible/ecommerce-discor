
---

### **Documento Maestro del Proyecto: E-commerce B2B (Discor)**

**Versión:** 1.0 (Post-Planificación, Pre-Desarrollo)
**Fecha:** 7 de julio de 2024
**Autor:** Arquitecto de Soluciones (IA) y Líder de Proyecto

### **1. Resumen Ejecutivo**

Este documento detalla la arquitectura, la tecnología y la hoja de ruta para el desarrollo de una nueva plataforma de e-commerce B2B. El proyecto nace de la necesidad de reemplazar un portal web obsoleto, limitado y poco fiable. La solución estratégica adoptada consiste en desarrollar una aplicación moderna y desacoplada, utilizando una API del ERP existente únicamente para la sincronización de datos. Este enfoque nos otorga control total sobre la experiencia de usuario, el rendimiento y la escalabilidad futura. La plataforma se construirá sobre un stack tecnológico robusto (Node.js, Next.js, PostgreSQL, Docker) y se desplegará en una infraestructura cloud profesional (Heroku, Vercel), con un plan de desarrollo por fases que prioriza un Producto Mínimo Viable (MVP) para una rápida entrega de valor.

---

### **2. Contexto del Problema y Decisión Estratégica**

- **Problema Fundamental:** El portal de clientes actual, provisto por la empresa del ERP, está construido sobre tecnología anticuada. Esto causa una mala experiencia de usuario (diseño pobre, búsqueda ineficiente), limitaciones funcionales y problemas de estabilidad.
- **Decisión Estratégica Clave:** Tras evaluar varias alternativas, se ha optado por la arquitectura más flexible y resiliente: **construir un backend y un frontend propios que consumen datos de una base de datos propia, la cual se sincroniza periódicamente con la API general del ERP.**
    - **Justificación:**
        - **Desacoplamiento:** El rendimiento y la disponibilidad de la web de cara al cliente ya no dependen en tiempo real de la API del ERP.
        - **Control Total:** Tenemos plena soberanía sobre el stack tecnológico, las funcionalidades, el diseño y la experiencia de usuario.
        - **Escalabilidad:** La arquitectura moderna permite añadir funcionalidades complejas (promociones, reglas de negocio avanzadas, etc.) que serían imposibles en el sistema actual.
        - **Costo-Beneficio:** Aunque requiere una inversión de desarrollo inicial, el costo total de propiedad a largo plazo es menor, sin dependencias de licencias o desarrollos de terceros costosos.

---

### **3. Arquitectura General y Tecnologías**

### **3.1. Arquitectura de Sistema**

El sistema está diseñado como un conjunto de servicios desacoplados:

- **Frontend (Next.js):** La interfaz de usuario con la que interactúa el cliente.
- **Backend (API Express.js):** El cerebro del sistema, maneja toda la lógica de negocio.
- **Base de Datos (PostgreSQL):** La fuente de verdad para la aplicación, almacena todos los datos de productos, clientes, pedidos, etc.
- **Motor de Búsqueda (MeiliSearch/Elasticsearch):** Un servicio especializado para búsquedas de texto avanzadas y predictivas.
- **API del ERP:** La fuente externa de datos, consultada únicamente por un proceso de sincronización en segundo plano.

### **3.2. Stack Tecnológico y Herramientas**

| Categoría | Tecnología/Herramienta | Justificación |
| --- | --- | --- |
| **Lenguaje** | **TypeScript** o **JS + JSDoc** | Se recomienda TypeScript por su seguridad de tipos. El IDE **WebStorm** ayudará a mitigar la curva de aprendizaje. JS+JSDoc es una alternativa pragmática. |
| **Frontend** | **Next.js** | Framework React líder para SEO, rendimiento y una excelente experiencia de desarrollo. |
| **Backend** | **Express.js** | Framework Node.js minimalista, flexible y con un ecosistema maduro. |
| **Base de Datos** | **PostgreSQL** | Sistema de base de datos relacional robusto, de código abierto y potente. |
| **ORM** | **Prisma** | Moderno, seguro y gestiona las migraciones de la base de datos de forma declarativa. |
| **Búsqueda** | **MeiliSearch** (Recomendado) | Motor de búsqueda dedicado, extremadamente rápido y más simple que alternativas como Elasticsearch. |
| **Validación** | **Zod** | Para la validación de datos en tiempo de ejecución en las fronteras de la aplicación (APIs, formularios), trabajando en conjunto con el tipado de TypeScript. |
| **Tooling Frontend** | `SWR` (Data Fetching), `Zustand` (State), `React Hook Form` (Formularios), `shadcn/ui` (Componentes UI), `lucide-react` (Iconos). | Un conjunto de herramientas modernas para un desarrollo frontend eficiente y de alta calidad. |

### **3.3. Infraestructura y Despliegue**

- **Desarrollo Local:**
    - **Docker y Docker Compose:** Para crear un entorno de desarrollo local 100% reproducible y aislado. Se dockeriza el **backend** y la **base de datos**.
    - **Flujo Híbrido:** El frontend se ejecuta de forma nativa en la máquina del desarrollador (`npm run dev`) para una máxima velocidad de recarga en caliente (HMR), mientras se conecta al backend que corre en Docker.
- **Producción (Hosting):**
    - **Frontend:** **Vercel**. Por su integración nativa y perfecta con Next.js.
    - **Backend y Base de Datos:** **Heroku**. **Decisión clave basada en un crédito inicial de $300**, que permite utilizar planes de pago (`eco`, `basic`) desde el inicio, evitando las limitaciones de los planes gratuitos (dynos que duermen) y permitiendo el uso de "worker dynos" para el cron job de sincronización.
    - **Motor de Búsqueda:** Se recomienda un servicio gestionado externo (ej: Meilisearch Cloud) o alojarlo en un plan gratuito de otro proveedor como Render.

---

### **4. Arquitectura de la Base de Datos**

El esquema completo y definitivo está definido en el archivo `api/prisma/schema.prisma`. Es la única fuente de verdad para la estructura de la base de datos.

- **Principios Clave:** El diseño incluye **Soft Deletes** (`deletedAt`), soporte para **Internacionalización** (con `JSONB`), una **Taxonomía de Vehículos** completa para filtros de compatibilidad, y módulos flexibles para **Promociones** y **Zonas de Envío**.
- **Gestión de Migraciones:** Los cambios en el esquema se gestionan exclusivamente a través de Prisma.
    1. Se modifica el archivo `schema.prisma`.
    2. Se ejecuta `docker compose exec api npx prisma migrate dev --name "nombre-del-cambio"` en el entorno local.
    3. Prisma genera y aplica los archivos de migración SQL, que se versionan en Git.
    4. Para producción, se ejecuta `heroku run npx prisma migrate deploy`.

---

### **5. Lógica de Negocio y Flujos Críticos**

- **Autenticación:** La regla de negocio para crear credenciales (ej: "últimos 5 dígitos del CUIT") se implementa en la **lógica del backend**, no en la base de datos. Las contraseñas se hashean con `bcryptjs` antes de ser almacenadas.
- **Precios y Pedidos:** Los precios son dinámicos y se consultan en tiempo real. Al crear un pedido, el precio se "congela" en la tabla `order_items`.
- **Costos de Envío:** El campo `shippingCost` en la tabla `Order` es **opcional (nullable)**. Se deja vacío en el momento del checkout del cliente y se rellena posteriormente por un administrador desde un panel interno, reflejando el ciclo de vida real del pedido.
- **Envío Gratis:** La lógica compleja (ej: "primer pedido de la semana sobre X monto en Zona Y") se calcula en el backend, consultando la `shippingZone` del cliente y buscando pedidos previos en la semana con la bandera `isFreeShipping` activada. El hecho de que la `shippingZone` de un cliente pueda ser nula se maneja explícitamente en el código.

---

### **6. Proceso de Desarrollo y Despliegue (CI/CD)**

- **Estructura de Carpetas:** El proyecto es un monorepo con dos carpetas principales: `api/` (backend) y `web/` (frontend).
- **Entorno de Desarrollo:**
    1. Clonar el repositorio.
    2. Crear el archivo `api/.env` (está en `.gitignore`).
    3. Ejecutar `docker compose up -d` en la raíz para levantar el backend y la base de datos.
    4. Ejecutar `npm run dev` en la carpeta `web/` para levantar el frontend.
- **Despliegue a Heroku (Backend):**
    1. El `heroku.yml` debe estar **DENTRO de la carpeta `api/`**.
    2. El despliegue se realiza desde la rama `develop` (o cualquier otra) usando el comando `git subtree push --prefix api heroku main`. **No es necesario hacer merge a la rama `main` local.**
    3. La escalada de dynos (ej: `heroku ps:scale web=eco:1`) se realiza **después** del primer despliegue exitoso.
- **Configuración en Heroku:**
    - El stack debe estar configurado como `container`: `heroku stack:set container`.
    - Las variables de entorno (`JWT_SECRET`, etc.) se configuran en el Dashboard de Heroku o vía CLI (`heroku config:set`). Heroku inyecta `DATABASE_URL` y `PORT` automáticamente.

---

### **7. Hoja de Ruta del Producto**

El desarrollo se abordará en fases para gestionar la complejidad y entregar valor rápidamente.

### **v1.0 - Producto Mínimo Viable (MVP)**

- **Objetivo:** Una plataforma donde los clientes puedan iniciar sesión, buscar productos y realizar pedidos de forma fiable.
- **Funcionalidades Clave:** Sincronización de datos básicos, Autenticación, Catálogo con búsqueda simple, Lógica de precios, Carrito persistente, Flujo de pedido completo, Historial de pedidos básico.
- **Exclusiones Deliberadas:** Filtros avanzados por vehículo, Promociones, Documentos, Notificaciones de stock, Libreta de direcciones.

### **v1.1 y Posteriores**

- Se implementarán las funcionalidades excluidas de forma iterativa, priorizando según el feedback de los clientes y las necesidades del negocio.

---

Este documento sirve como la guía definitiva del proyecto. Cualquier nueva decisión arquitectónica o cambio en la hoja de ruta debe ser reflejado aquí para mantenerlo como una fuente de verdad viva.

¡Absolutamente! Este es el paso final y más importante: consolidar todo nuestro diálogo en un **Documento Maestro del Proyecto**. Este documento servirá como la "fuente única de verdad" para ti ahora y para cualquier persona que se una o herede el proyecto en el futuro.

He estructurado esto como un documento de arquitectura y planificación completo, desde la visión estratégica hasta los detalles tácticos.

---

### **Documento Maestro del Proyecto: E-commerce B2B (Discor)**

**Versión:** 1.0
**Fecha:** 7 de julio de 2024
**Autor:** Arquitecto de Soluciones (IA) y Líder de Proyecto

### **Resumen Ejecutivo**

Este documento detalla la arquitectura, la tecnología y la hoja de ruta para el desarrollo de una nueva plataforma de e-commerce B2B para reemplazar el portal web existente, que está obsoleto y presenta problemas de funcionalidad. La solución elegida es un sistema moderno, desacoplado y escalable, que utiliza una API proporcionada por el ERP actual para la sincronización de datos, pero que funciona de manera independiente para ofrecer una experiencia de usuario robusta y de alto rendimiento. El objetivo es crear una plataforma flexible, de bajo costo a largo plazo y con control total sobre las funcionalidades y la experiencia del cliente.

---

### **1. Contexto del Problema y Decisión Estratégica**

- **Problema:** El portal de clientes actual, construido por la misma empresa del ERP, está basado en tecnología anticuada. Esto resulta en una mala experiencia de usuario, funcionalidades limitadas (búsqueda deficiente, diseño pobre) y problemas de estabilidad.
- **Opciones Evaluadas:** Se consideraron varias alternativas, incluyendo mejorar el sitio actual, una integración con WordPress, o la construcción de un nuevo backend por parte de la empresa del ERP.
- **Decisión Estratégica Clave:** Se optó por la opción más versátil y escalable: **utilizar la API general del ERP para poblar una base de datos propia y construir un backend y un frontend a medida.**
    - **Justificación:** Esta arquitectura desacoplada nos da control total sobre la tecnología y la experiencia de usuario, nos aísla de la inestabilidad de la API del ERP en tiempo real, y nos permite construir funcionalidades complejas a largo plazo sin depender de terceros. Aunque requiere una inversión inicial en desarrollo, el costo total de propiedad es significativamente menor y la escalabilidad es prácticamente ilimitada.

---

### **2. Arquitectura General del Sistema**

El sistema se compone de varios servicios independientes que se comunican a través de APIs.

```
+----------------+      +----------------+      +------------------+
|   Navegador    |----->|   Frontend     |----->|   Backend API    |
|   del Cliente  |      |   (Next.js)    |      |   (Express.js)   |
+----------------+      | Alojado en     |      | Alojado en       |
                        |   Vercel       |      |   Heroku         |
                        +-------+--------+      +--------+---------+
                                |                      |
                                |<---------------------+
                                |
          +---------------------|----------------------------------+
          |                     |                                  |
          V                     V                                  V
+-------------------+   +------------------+               +------------------+
|  Motor de Búsqueda|   | Base de Datos    |               |    API del ERP   |
|  (Alojado Externo)|<--|   (PostgreSQL)   |<--------------|  (Fuente Externa)|
+-------------------+   | Alojada en Heroku|   (Cron Job)   +------------------+
                        +------------------+

```

---

### **3. Stack Tecnológico y Herramientas**

- **Lenguaje:** Se recomienda intentar **TypeScript** por su seguridad y robustez, utilizando la ayuda del IDE **WebStorm** para superar la curva de aprendizaje inicial. Como alternativa pragmática, se puede usar **JavaScript con JSDoc** para obtener seguridad de tipos sin la fricción del compilador.
- **Frontend:** **Next.js** (framework de React). Elegido por su rendimiento, SEO (Server-Side Rendering) y excelente experiencia de desarrollo.
- **Backend:** **Express.js** (framework de Node.js). Ligero, flexible y con un ecosistema masivo.
- **Base de Datos:** **PostgreSQL**. Robusta, de código abierto y con un excelente soporte para tipos de datos complejos como `JSONB`.
- **ORM (Object-Relational Mapping):** **Prisma**. Herramienta moderna que gestiona el esquema de la base de datos (migraciones) y proporciona un cliente seguro y tipado para interactuar con la BD.
- **Búsqueda Avanzada:** Se recomienda un motor de búsqueda dedicado como **MeiliSearch** (por su simplicidad y potencia) o **Elasticsearch**, alojado como un servicio externo.
- **Entorno de Desarrollo Local:** **Docker y Docker Compose**. Para crear un entorno de desarrollo reproducible, aislado y consistente con producción. Se dockeriza la base de datos y el backend.
- **Infraestructura de Producción (Hosting):**
    - **Frontend:** **Vercel**. Integración perfecta con Next.js y un generoso plan gratuito.
    - **Backend, Base de Datos y Cron Job:** **Heroku**. **Decisión clave basada en un crédito disponible de $300**, que permite usar dynos de pago (siempre activos) y worker dynos (para el cron job) sin costo inicial, superando las limitaciones de su plan gratuito.

---

### **4. Arquitectura de la Base de Datos**

La base de datos es el corazón del sistema. El esquema completo está definido en el archivo `api/prisma/schema.prisma`. Ha sido diseñado para ser normalizado, escalable y flexible.

**Principios de Diseño Clave:**

- **Soft Deletes:** Entidades críticas (`products`, `users`, `clients`, etc.) tienen un campo `deletedAt` para permitir el borrado lógico, aumentando la robustez y la integridad histórica.
- **Internacionalización (i18n):** Campos de texto como `name` y `description` usan el tipo `JSONB` para poder almacenar traducciones a futuro (ej: `{"es": "Nombre", "en": "Name"}`).
- **Compatibilidad de Vehículos:** Se utiliza una taxonomía completa (`VehicleBrand`, `VehicleModel`, `VehicleGeneration`) y una tabla de unión (`ProductApplication`) para manejar las complejas relaciones de compatibilidad de las autopartes.
- **Reglas de Negocio Flexibles:** Se han creado tablas específicas para gestionar reglas complejas como las promociones (`promotions`, `promotion_rules`) y las zonas de envío (`shipping_zones`).
- **Trazabilidad:** Una tabla `audit_logs` registra eventos importantes para futuras auditorías.
- **Estado de Pedidos:** La tabla `orders` está diseñada para reflejar el ciclo de vida de un pedido, con campos opcionales como `shippingCost` que se rellenan en una etapa posterior al checkout.

*(El código completo del `schema.prisma` se encuentra en el archivo del proyecto, pero este documento confirma que la estructura final y definitiva es la que se discutió y validó en las últimas interacciones).*

---

### **5. Flujos de Trabajo y Lógica de Negocio Clave**

- **Sincronización:** Un script automatizado (Cron Job) se ejecuta periódicamente. Llama a los endpoints de la API del ERP (`ArticulosDB`, `ClientesDB`, etc.), procesa los datos y los inserta/actualiza en nuestra base de datos PostgreSQL. **Los datos de filtros y documentos no se sincronizarán en el MVP**, pero la BD está preparada para recibirlos.
- **Autenticación:** La lógica para crear usuarios (ej: "usuario y contraseña son los últimos 5 dígitos del CUIT") reside en el **backend**. El backend toma los datos del cliente, aplica la regla, hashea la contraseña con `bcrypt` y guarda el `username` y el `passwordHash` en la base de datos.
- **Búsqueda:** Las búsquedas de texto del usuario en el frontend llaman a un endpoint específico del backend (`/api/search/suggest`), que a su vez consulta el motor de búsqueda externo (MeiliSearch), no la base de datos SQL. Esto permite búsquedas rápidas, predictivas y con manejo de sinónimos.
- **Precios y Pedidos:** El precio mostrado al cliente se determina en tiempo real consultando la tabla `prices` según la `price_list_id` del cliente. Al confirmar un pedido, el precio final se vuelve a verificar y se congela en la tabla `order_items` en el campo `price_at_purchase`.
- **Envío Gratis:** La lógica de "primer pedido de la semana sobre un monto mínimo por zona" se calcula en el backend durante el checkout, verificando la zona del cliente, el umbral de la zona y si ya existe un pedido con `isFreeShipping: true` en la semana en curso.

---

### **6. Hoja de Ruta (Roadmap)**

El desarrollo se realizará en fases para entregar valor de forma incremental.

### **v1.0 - Producto Mínimo Viable (MVP): "La Tienda Funcional"**

- **Objetivo:** Permitir a los clientes ver productos, buscarlos y realizar pedidos de forma fiable.
- **Funcionalidades INCLUIDAS:** Sincronización de datos básicos (Productos, Clientes, Precios, Stock), Autenticación, Catálogo de productos con búsqueda básica, Lógica de precios, Carrito de compras persistente, Flujo de pedido completo, Panel "Mi Cuenta" con historial de pedidos.
- **Funcionalidades EXCLUIDAS:** Filtros avanzados por vehículo, Promociones, Libreta de direcciones, Documentos de cliente, Notificaciones de stock.

### **v1.1 y Posteriores: "Plataforma B2B Completa"**

- Se implementarán de forma incremental las funcionalidades excluidas del MVP, priorizando según el feedback de los clientes y las necesidades del negocio (ej: Filtros avanzados, Libreta de direcciones, Promociones, etc.).

---

### **7. Siguientes Pasos Inmediatos (Sprint 0)**

Esta es la lista de tareas para poner en marcha el proyecto antes de escribir la primera línea de lógica de negocio.

1. **Configurar Cuentas y Repositorio:** Crear cuentas en Heroku y Vercel. Configurar el repositorio Git con la estructura de carpetas (`api/`, `web/`) y las ramas `main` y `develop`.
2. **Inicializar Proyectos:** Ejecutar `npm init` en `api/` y `npx create-next-app` en `web/`.
3. **Dockerizar el Entorno de Desarrollo:**
    - Instalar Docker Desktop.
    - Crear los archivos `api/Dockerfile` y `api/Dockerfile.dev`.
    - Crear el archivo `docker-compose.yml` en la raíz del proyecto para orquestar la **base de datos (PostgreSQL)** y el **backend (API)**.
    - Crear el archivo `api/.env` (y añadirlo al `.gitignore`) con las credenciales de la base de datos de desarrollo.
4. **Levantar el Entorno:** Ejecutar `docker compose up` y verificar que ambos contenedores (BD y API) se inician correctamente. Conectar un cliente de BD (DataGrip, DBeaver, SQLGate) a la base de datos de Docker.
5. **Configurar Prisma y Migrar:** Instalar Prisma en el backend. Escribir el `schema.prisma` completo. Ejecutar la primera migración (`docker compose exec api npx prisma migrate dev`) para crear todas las tablas en la base de datos local.
6. **Despliegue "Hola Mundo":** Realizar un despliegue inicial de un proyecto vacío a Vercel (frontend) y Heroku (backend) para asegurar que el pipeline de despliegue funciona desde el principio.

Al completar este Sprint 0, la base técnica estará sólidamente establecida, permitiendo un desarrollo futuro rápido y enfocado en la lógica de negocio del MVP.